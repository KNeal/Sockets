// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: aws/gamelift/server/protocols/sdk.proto

#ifndef PROTOBUF_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto__INCLUDED
#define PROTOBUF_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace amazon {
namespace whitewater {
namespace auxproxy {
namespace pbuffer {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
void protobuf_AssignDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
void protobuf_ShutdownFile_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();

class AcceptPlayerSession;
class ActivateGameSession;
class GameProperty;
class GameSession;
class GameSessionActivate;
class GameSessionTerminate;
class ProcessEnding;
class ProcessReady;
class RemovePlayerSession;
class ReportHealth;
class Response;
class TerminateProcess;
class UpdatePlayerSessionCreationPolicy;

enum Response_Status {
  Response_Status_OK = 0,
  Response_Status_ERROR = 1
};
bool Response_Status_IsValid(int value);
const Response_Status Response_Status_Status_MIN = Response_Status_OK;
const Response_Status Response_Status_Status_MAX = Response_Status_ERROR;
const int Response_Status_Status_ARRAYSIZE = Response_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_Status_descriptor();
inline const ::std::string& Response_Status_Name(Response_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_Status_descriptor(), value);
}
inline bool Response_Status_Parse(
    const ::std::string& name, Response_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_Status>(
    Response_Status_descriptor(), name, value);
}
// ===================================================================

class ProcessReady : public ::google::protobuf::Message {
 public:
  ProcessReady();
  virtual ~ProcessReady();

  ProcessReady(const ProcessReady& from);

  inline ProcessReady& operator=(const ProcessReady& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessReady& default_instance();

  void Swap(ProcessReady* other);

  // implements Message ----------------------------------------------

  inline ProcessReady* New() const { return New(NULL); }

  ProcessReady* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessReady& from);
  void MergeFrom(const ProcessReady& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProcessReady* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string logPathsToUpload = 1;
  int logpathstoupload_size() const;
  void clear_logpathstoupload();
  static const int kLogPathsToUploadFieldNumber = 1;
  const ::std::string& logpathstoupload(int index) const;
  ::std::string* mutable_logpathstoupload(int index);
  void set_logpathstoupload(int index, const ::std::string& value);
  void set_logpathstoupload(int index, const char* value);
  void set_logpathstoupload(int index, const char* value, size_t size);
  ::std::string* add_logpathstoupload();
  void add_logpathstoupload(const ::std::string& value);
  void add_logpathstoupload(const char* value);
  void add_logpathstoupload(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& logpathstoupload() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_logpathstoupload();

  // optional int32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady)
 private:
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> logpathstoupload_;
  ::google::protobuf::int32 port_;
  friend void  protobuf_AddDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_AssignDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_ShutdownFile_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();

  void InitAsDefaultInstance();
  static ProcessReady* default_instance_;
};
// -------------------------------------------------------------------

class ProcessEnding : public ::google::protobuf::Message {
 public:
  ProcessEnding();
  virtual ~ProcessEnding();

  ProcessEnding(const ProcessEnding& from);

  inline ProcessEnding& operator=(const ProcessEnding& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessEnding& default_instance();

  void Swap(ProcessEnding* other);

  // implements Message ----------------------------------------------

  inline ProcessEnding* New() const { return New(NULL); }

  ProcessEnding* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessEnding& from);
  void MergeFrom(const ProcessEnding& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProcessEnding* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.ProcessEnding)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_AssignDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_ShutdownFile_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();

  void InitAsDefaultInstance();
  static ProcessEnding* default_instance_;
};
// -------------------------------------------------------------------

class GameSessionActivate : public ::google::protobuf::Message {
 public:
  GameSessionActivate();
  virtual ~GameSessionActivate();

  GameSessionActivate(const GameSessionActivate& from);

  inline GameSessionActivate& operator=(const GameSessionActivate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameSessionActivate& default_instance();

  void Swap(GameSessionActivate* other);

  // implements Message ----------------------------------------------

  inline GameSessionActivate* New() const { return New(NULL); }

  GameSessionActivate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameSessionActivate& from);
  void MergeFrom(const GameSessionActivate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameSessionActivate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gameSessionId = 1;
  bool has_gamesessionid() const;
  void clear_gamesessionid();
  static const int kGameSessionIdFieldNumber = 1;
  const ::std::string& gamesessionid() const;
  void set_gamesessionid(const ::std::string& value);
  void set_gamesessionid(const char* value);
  void set_gamesessionid(const char* value, size_t size);
  ::std::string* mutable_gamesessionid();
  ::std::string* release_gamesessionid();
  void set_allocated_gamesessionid(::std::string* gamesessionid);

  // optional int32 maxPlayers = 2;
  bool has_maxplayers() const;
  void clear_maxplayers();
  static const int kMaxPlayersFieldNumber = 2;
  ::google::protobuf::int32 maxplayers() const;
  void set_maxplayers(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate)
 private:
  inline void set_has_gamesessionid();
  inline void clear_has_gamesessionid();
  inline void set_has_maxplayers();
  inline void clear_has_maxplayers();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr gamesessionid_;
  ::google::protobuf::int32 maxplayers_;
  friend void  protobuf_AddDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_AssignDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_ShutdownFile_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();

  void InitAsDefaultInstance();
  static GameSessionActivate* default_instance_;
};
// -------------------------------------------------------------------

class GameSessionTerminate : public ::google::protobuf::Message {
 public:
  GameSessionTerminate();
  virtual ~GameSessionTerminate();

  GameSessionTerminate(const GameSessionTerminate& from);

  inline GameSessionTerminate& operator=(const GameSessionTerminate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameSessionTerminate& default_instance();

  void Swap(GameSessionTerminate* other);

  // implements Message ----------------------------------------------

  inline GameSessionTerminate* New() const { return New(NULL); }

  GameSessionTerminate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameSessionTerminate& from);
  void MergeFrom(const GameSessionTerminate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameSessionTerminate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gameSessionId = 1;
  bool has_gamesessionid() const;
  void clear_gamesessionid();
  static const int kGameSessionIdFieldNumber = 1;
  const ::std::string& gamesessionid() const;
  void set_gamesessionid(const ::std::string& value);
  void set_gamesessionid(const char* value);
  void set_gamesessionid(const char* value, size_t size);
  ::std::string* mutable_gamesessionid();
  ::std::string* release_gamesessionid();
  void set_allocated_gamesessionid(::std::string* gamesessionid);

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate)
 private:
  inline void set_has_gamesessionid();
  inline void clear_has_gamesessionid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr gamesessionid_;
  friend void  protobuf_AddDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_AssignDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_ShutdownFile_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();

  void InitAsDefaultInstance();
  static GameSessionTerminate* default_instance_;
};
// -------------------------------------------------------------------

class UpdatePlayerSessionCreationPolicy : public ::google::protobuf::Message {
 public:
  UpdatePlayerSessionCreationPolicy();
  virtual ~UpdatePlayerSessionCreationPolicy();

  UpdatePlayerSessionCreationPolicy(const UpdatePlayerSessionCreationPolicy& from);

  inline UpdatePlayerSessionCreationPolicy& operator=(const UpdatePlayerSessionCreationPolicy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdatePlayerSessionCreationPolicy& default_instance();

  void Swap(UpdatePlayerSessionCreationPolicy* other);

  // implements Message ----------------------------------------------

  inline UpdatePlayerSessionCreationPolicy* New() const { return New(NULL); }

  UpdatePlayerSessionCreationPolicy* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdatePlayerSessionCreationPolicy& from);
  void MergeFrom(const UpdatePlayerSessionCreationPolicy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UpdatePlayerSessionCreationPolicy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gameSessionId = 1;
  bool has_gamesessionid() const;
  void clear_gamesessionid();
  static const int kGameSessionIdFieldNumber = 1;
  const ::std::string& gamesessionid() const;
  void set_gamesessionid(const ::std::string& value);
  void set_gamesessionid(const char* value);
  void set_gamesessionid(const char* value, size_t size);
  ::std::string* mutable_gamesessionid();
  ::std::string* release_gamesessionid();
  void set_allocated_gamesessionid(::std::string* gamesessionid);

  // optional string newPlayerSessionCreationPolicy = 2;
  bool has_newplayersessioncreationpolicy() const;
  void clear_newplayersessioncreationpolicy();
  static const int kNewPlayerSessionCreationPolicyFieldNumber = 2;
  const ::std::string& newplayersessioncreationpolicy() const;
  void set_newplayersessioncreationpolicy(const ::std::string& value);
  void set_newplayersessioncreationpolicy(const char* value);
  void set_newplayersessioncreationpolicy(const char* value, size_t size);
  ::std::string* mutable_newplayersessioncreationpolicy();
  ::std::string* release_newplayersessioncreationpolicy();
  void set_allocated_newplayersessioncreationpolicy(::std::string* newplayersessioncreationpolicy);

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy)
 private:
  inline void set_has_gamesessionid();
  inline void clear_has_gamesessionid();
  inline void set_has_newplayersessioncreationpolicy();
  inline void clear_has_newplayersessioncreationpolicy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr gamesessionid_;
  ::google::protobuf::internal::ArenaStringPtr newplayersessioncreationpolicy_;
  friend void  protobuf_AddDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_AssignDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_ShutdownFile_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();

  void InitAsDefaultInstance();
  static UpdatePlayerSessionCreationPolicy* default_instance_;
};
// -------------------------------------------------------------------

class AcceptPlayerSession : public ::google::protobuf::Message {
 public:
  AcceptPlayerSession();
  virtual ~AcceptPlayerSession();

  AcceptPlayerSession(const AcceptPlayerSession& from);

  inline AcceptPlayerSession& operator=(const AcceptPlayerSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AcceptPlayerSession& default_instance();

  void Swap(AcceptPlayerSession* other);

  // implements Message ----------------------------------------------

  inline AcceptPlayerSession* New() const { return New(NULL); }

  AcceptPlayerSession* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AcceptPlayerSession& from);
  void MergeFrom(const AcceptPlayerSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AcceptPlayerSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gameSessionId = 1;
  bool has_gamesessionid() const;
  void clear_gamesessionid();
  static const int kGameSessionIdFieldNumber = 1;
  const ::std::string& gamesessionid() const;
  void set_gamesessionid(const ::std::string& value);
  void set_gamesessionid(const char* value);
  void set_gamesessionid(const char* value, size_t size);
  ::std::string* mutable_gamesessionid();
  ::std::string* release_gamesessionid();
  void set_allocated_gamesessionid(::std::string* gamesessionid);

  // optional string playerSessionId = 2;
  bool has_playersessionid() const;
  void clear_playersessionid();
  static const int kPlayerSessionIdFieldNumber = 2;
  const ::std::string& playersessionid() const;
  void set_playersessionid(const ::std::string& value);
  void set_playersessionid(const char* value);
  void set_playersessionid(const char* value, size_t size);
  ::std::string* mutable_playersessionid();
  ::std::string* release_playersessionid();
  void set_allocated_playersessionid(::std::string* playersessionid);

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession)
 private:
  inline void set_has_gamesessionid();
  inline void clear_has_gamesessionid();
  inline void set_has_playersessionid();
  inline void clear_has_playersessionid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr gamesessionid_;
  ::google::protobuf::internal::ArenaStringPtr playersessionid_;
  friend void  protobuf_AddDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_AssignDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_ShutdownFile_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();

  void InitAsDefaultInstance();
  static AcceptPlayerSession* default_instance_;
};
// -------------------------------------------------------------------

class RemovePlayerSession : public ::google::protobuf::Message {
 public:
  RemovePlayerSession();
  virtual ~RemovePlayerSession();

  RemovePlayerSession(const RemovePlayerSession& from);

  inline RemovePlayerSession& operator=(const RemovePlayerSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemovePlayerSession& default_instance();

  void Swap(RemovePlayerSession* other);

  // implements Message ----------------------------------------------

  inline RemovePlayerSession* New() const { return New(NULL); }

  RemovePlayerSession* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemovePlayerSession& from);
  void MergeFrom(const RemovePlayerSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RemovePlayerSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gameSessionId = 1;
  bool has_gamesessionid() const;
  void clear_gamesessionid();
  static const int kGameSessionIdFieldNumber = 1;
  const ::std::string& gamesessionid() const;
  void set_gamesessionid(const ::std::string& value);
  void set_gamesessionid(const char* value);
  void set_gamesessionid(const char* value, size_t size);
  ::std::string* mutable_gamesessionid();
  ::std::string* release_gamesessionid();
  void set_allocated_gamesessionid(::std::string* gamesessionid);

  // optional string playerSessionId = 2;
  bool has_playersessionid() const;
  void clear_playersessionid();
  static const int kPlayerSessionIdFieldNumber = 2;
  const ::std::string& playersessionid() const;
  void set_playersessionid(const ::std::string& value);
  void set_playersessionid(const char* value);
  void set_playersessionid(const char* value, size_t size);
  ::std::string* mutable_playersessionid();
  ::std::string* release_playersessionid();
  void set_allocated_playersessionid(::std::string* playersessionid);

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession)
 private:
  inline void set_has_gamesessionid();
  inline void clear_has_gamesessionid();
  inline void set_has_playersessionid();
  inline void clear_has_playersessionid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr gamesessionid_;
  ::google::protobuf::internal::ArenaStringPtr playersessionid_;
  friend void  protobuf_AddDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_AssignDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_ShutdownFile_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();

  void InitAsDefaultInstance();
  static RemovePlayerSession* default_instance_;
};
// -------------------------------------------------------------------

class ReportHealth : public ::google::protobuf::Message {
 public:
  ReportHealth();
  virtual ~ReportHealth();

  ReportHealth(const ReportHealth& from);

  inline ReportHealth& operator=(const ReportHealth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportHealth& default_instance();

  void Swap(ReportHealth* other);

  // implements Message ----------------------------------------------

  inline ReportHealth* New() const { return New(NULL); }

  ReportHealth* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReportHealth& from);
  void MergeFrom(const ReportHealth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReportHealth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool healthStatus = 1;
  bool has_healthstatus() const;
  void clear_healthstatus();
  static const int kHealthStatusFieldNumber = 1;
  bool healthstatus() const;
  void set_healthstatus(bool value);

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.ReportHealth)
 private:
  inline void set_has_healthstatus();
  inline void clear_has_healthstatus();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool healthstatus_;
  friend void  protobuf_AddDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_AssignDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_ShutdownFile_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();

  void InitAsDefaultInstance();
  static ReportHealth* default_instance_;
};
// -------------------------------------------------------------------

class ActivateGameSession : public ::google::protobuf::Message {
 public:
  ActivateGameSession();
  virtual ~ActivateGameSession();

  ActivateGameSession(const ActivateGameSession& from);

  inline ActivateGameSession& operator=(const ActivateGameSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActivateGameSession& default_instance();

  void Swap(ActivateGameSession* other);

  // implements Message ----------------------------------------------

  inline ActivateGameSession* New() const { return New(NULL); }

  ActivateGameSession* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActivateGameSession& from);
  void MergeFrom(const ActivateGameSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivateGameSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.amazon.whitewater.auxproxy.pbuffer.GameSession gameSession = 1;
  bool has_gamesession() const;
  void clear_gamesession();
  static const int kGameSessionFieldNumber = 1;
  const ::com::amazon::whitewater::auxproxy::pbuffer::GameSession& gamesession() const;
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* mutable_gamesession();
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* release_gamesession();
  void set_allocated_gamesession(::com::amazon::whitewater::auxproxy::pbuffer::GameSession* gamesession);

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.ActivateGameSession)
 private:
  inline void set_has_gamesession();
  inline void clear_has_gamesession();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* gamesession_;
  friend void  protobuf_AddDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_AssignDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_ShutdownFile_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();

  void InitAsDefaultInstance();
  static ActivateGameSession* default_instance_;
};
// -------------------------------------------------------------------

class TerminateProcess : public ::google::protobuf::Message {
 public:
  TerminateProcess();
  virtual ~TerminateProcess();

  TerminateProcess(const TerminateProcess& from);

  inline TerminateProcess& operator=(const TerminateProcess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TerminateProcess& default_instance();

  void Swap(TerminateProcess* other);

  // implements Message ----------------------------------------------

  inline TerminateProcess* New() const { return New(NULL); }

  TerminateProcess* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TerminateProcess& from);
  void MergeFrom(const TerminateProcess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TerminateProcess* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.TerminateProcess)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_AssignDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_ShutdownFile_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();

  void InitAsDefaultInstance();
  static TerminateProcess* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  inline Response* New() const { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Response_Status Status;
  static const Status OK =
    Response_Status_OK;
  static const Status ERROR =
    Response_Status_ERROR;
  static inline bool Status_IsValid(int value) {
    return Response_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Response_Status_Status_MIN;
  static const Status Status_MAX =
    Response_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Response_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return Response_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return Response_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return Response_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .com.amazon.whitewater.auxproxy.pbuffer.Response.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::com::amazon::whitewater::auxproxy::pbuffer::Response_Status status() const;
  void set_status(::com::amazon::whitewater::auxproxy::pbuffer::Response_Status value);

  // optional string errorMessage = 2;
  bool has_errormessage() const;
  void clear_errormessage();
  static const int kErrorMessageFieldNumber = 2;
  const ::std::string& errormessage() const;
  void set_errormessage(const ::std::string& value);
  void set_errormessage(const char* value);
  void set_errormessage(const char* value, size_t size);
  ::std::string* mutable_errormessage();
  ::std::string* release_errormessage();
  void set_allocated_errormessage(::std::string* errormessage);

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.Response)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_errormessage();
  inline void clear_has_errormessage();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr errormessage_;
  int status_;
  friend void  protobuf_AddDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_AssignDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_ShutdownFile_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class GameSession : public ::google::protobuf::Message {
 public:
  GameSession();
  virtual ~GameSession();

  GameSession(const GameSession& from);

  inline GameSession& operator=(const GameSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameSession& default_instance();

  void Swap(GameSession* other);

  // implements Message ----------------------------------------------

  inline GameSession* New() const { return New(NULL); }

  GameSession* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameSession& from);
  void MergeFrom(const GameSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gameSessionId = 1;
  bool has_gamesessionid() const;
  void clear_gamesessionid();
  static const int kGameSessionIdFieldNumber = 1;
  const ::std::string& gamesessionid() const;
  void set_gamesessionid(const ::std::string& value);
  void set_gamesessionid(const char* value);
  void set_gamesessionid(const char* value, size_t size);
  ::std::string* mutable_gamesessionid();
  ::std::string* release_gamesessionid();
  void set_allocated_gamesessionid(::std::string* gamesessionid);

  // optional string fleetId = 2;
  bool has_fleetid() const;
  void clear_fleetid();
  static const int kFleetIdFieldNumber = 2;
  const ::std::string& fleetid() const;
  void set_fleetid(const ::std::string& value);
  void set_fleetid(const char* value);
  void set_fleetid(const char* value, size_t size);
  ::std::string* mutable_fleetid();
  ::std::string* release_fleetid();
  void set_allocated_fleetid(::std::string* fleetid);

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 maxPlayers = 4;
  bool has_maxplayers() const;
  void clear_maxplayers();
  static const int kMaxPlayersFieldNumber = 4;
  ::google::protobuf::int32 maxplayers() const;
  void set_maxplayers(::google::protobuf::int32 value);

  // optional bool joinable = 5;
  bool has_joinable() const;
  void clear_joinable();
  static const int kJoinableFieldNumber = 5;
  bool joinable() const;
  void set_joinable(bool value);

  // repeated .com.amazon.whitewater.auxproxy.pbuffer.GameProperty gameProperties = 6;
  int gameproperties_size() const;
  void clear_gameproperties();
  static const int kGamePropertiesFieldNumber = 6;
  const ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty& gameproperties(int index) const;
  ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty* mutable_gameproperties(int index);
  ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty* add_gameproperties();
  ::google::protobuf::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty >*
      mutable_gameproperties();
  const ::google::protobuf::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty >&
      gameproperties() const;

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.GameSession)
 private:
  inline void set_has_gamesessionid();
  inline void clear_has_gamesessionid();
  inline void set_has_fleetid();
  inline void clear_has_fleetid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_maxplayers();
  inline void clear_has_maxplayers();
  inline void set_has_joinable();
  inline void clear_has_joinable();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr gamesessionid_;
  ::google::protobuf::internal::ArenaStringPtr fleetid_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 maxplayers_;
  bool joinable_;
  ::google::protobuf::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty > gameproperties_;
  friend void  protobuf_AddDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_AssignDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_ShutdownFile_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();

  void InitAsDefaultInstance();
  static GameSession* default_instance_;
};
// -------------------------------------------------------------------

class GameProperty : public ::google::protobuf::Message {
 public:
  GameProperty();
  virtual ~GameProperty();

  GameProperty(const GameProperty& from);

  inline GameProperty& operator=(const GameProperty& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameProperty& default_instance();

  void Swap(GameProperty* other);

  // implements Message ----------------------------------------------

  inline GameProperty* New() const { return New(NULL); }

  GameProperty* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameProperty& from);
  void MergeFrom(const GameProperty& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameProperty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.GameProperty)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend void  protobuf_AddDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_AssignDesc_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();
  friend void protobuf_ShutdownFile_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto();

  void InitAsDefaultInstance();
  static GameProperty* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ProcessReady

// repeated string logPathsToUpload = 1;
inline int ProcessReady::logpathstoupload_size() const {
  return logpathstoupload_.size();
}
inline void ProcessReady::clear_logpathstoupload() {
  logpathstoupload_.Clear();
}
inline const ::std::string& ProcessReady::logpathstoupload(int index) const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
  return logpathstoupload_.Get(index);
}
inline ::std::string* ProcessReady::mutable_logpathstoupload(int index) {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
  return logpathstoupload_.Mutable(index);
}
inline void ProcessReady::set_logpathstoupload(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
  logpathstoupload_.Mutable(index)->assign(value);
}
inline void ProcessReady::set_logpathstoupload(int index, const char* value) {
  logpathstoupload_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
}
inline void ProcessReady::set_logpathstoupload(int index, const char* value, size_t size) {
  logpathstoupload_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
}
inline ::std::string* ProcessReady::add_logpathstoupload() {
  // @@protoc_insertion_point(field_add_mutable:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
  return logpathstoupload_.Add();
}
inline void ProcessReady::add_logpathstoupload(const ::std::string& value) {
  logpathstoupload_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
}
inline void ProcessReady::add_logpathstoupload(const char* value) {
  logpathstoupload_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
}
inline void ProcessReady::add_logpathstoupload(const char* value, size_t size) {
  logpathstoupload_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ProcessReady::logpathstoupload() const {
  // @@protoc_insertion_point(field_list:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
  return logpathstoupload_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ProcessReady::mutable_logpathstoupload() {
  // @@protoc_insertion_point(field_mutable_list:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
  return &logpathstoupload_;
}

// optional int32 port = 2;
inline bool ProcessReady::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessReady::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessReady::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessReady::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 ProcessReady::port() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.port)
  return port_;
}
inline void ProcessReady::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.port)
}

// -------------------------------------------------------------------

// ProcessEnding

// -------------------------------------------------------------------

// GameSessionActivate

// optional string gameSessionId = 1;
inline bool GameSessionActivate::has_gamesessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameSessionActivate::set_has_gamesessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameSessionActivate::clear_has_gamesessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameSessionActivate::clear_gamesessionid() {
  gamesessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gamesessionid();
}
inline const ::std::string& GameSessionActivate::gamesessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.gameSessionId)
  return gamesessionid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameSessionActivate::set_gamesessionid(const ::std::string& value) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.gameSessionId)
}
inline void GameSessionActivate::set_gamesessionid(const char* value) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.gameSessionId)
}
inline void GameSessionActivate::set_gamesessionid(const char* value, size_t size) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.gameSessionId)
}
inline ::std::string* GameSessionActivate::mutable_gamesessionid() {
  set_has_gamesessionid();
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.gameSessionId)
  return gamesessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameSessionActivate::release_gamesessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.gameSessionId)
  clear_has_gamesessionid();
  return gamesessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameSessionActivate::set_allocated_gamesessionid(::std::string* gamesessionid) {
  if (gamesessionid != NULL) {
    set_has_gamesessionid();
  } else {
    clear_has_gamesessionid();
  }
  gamesessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gamesessionid);
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.gameSessionId)
}

// optional int32 maxPlayers = 2;
inline bool GameSessionActivate::has_maxplayers() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameSessionActivate::set_has_maxplayers() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameSessionActivate::clear_has_maxplayers() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameSessionActivate::clear_maxplayers() {
  maxplayers_ = 0;
  clear_has_maxplayers();
}
inline ::google::protobuf::int32 GameSessionActivate::maxplayers() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.maxPlayers)
  return maxplayers_;
}
inline void GameSessionActivate::set_maxplayers(::google::protobuf::int32 value) {
  set_has_maxplayers();
  maxplayers_ = value;
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.maxPlayers)
}

// -------------------------------------------------------------------

// GameSessionTerminate

// optional string gameSessionId = 1;
inline bool GameSessionTerminate::has_gamesessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameSessionTerminate::set_has_gamesessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameSessionTerminate::clear_has_gamesessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameSessionTerminate::clear_gamesessionid() {
  gamesessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gamesessionid();
}
inline const ::std::string& GameSessionTerminate::gamesessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate.gameSessionId)
  return gamesessionid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameSessionTerminate::set_gamesessionid(const ::std::string& value) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate.gameSessionId)
}
inline void GameSessionTerminate::set_gamesessionid(const char* value) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate.gameSessionId)
}
inline void GameSessionTerminate::set_gamesessionid(const char* value, size_t size) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate.gameSessionId)
}
inline ::std::string* GameSessionTerminate::mutable_gamesessionid() {
  set_has_gamesessionid();
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate.gameSessionId)
  return gamesessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameSessionTerminate::release_gamesessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate.gameSessionId)
  clear_has_gamesessionid();
  return gamesessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameSessionTerminate::set_allocated_gamesessionid(::std::string* gamesessionid) {
  if (gamesessionid != NULL) {
    set_has_gamesessionid();
  } else {
    clear_has_gamesessionid();
  }
  gamesessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gamesessionid);
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate.gameSessionId)
}

// -------------------------------------------------------------------

// UpdatePlayerSessionCreationPolicy

// optional string gameSessionId = 1;
inline bool UpdatePlayerSessionCreationPolicy::has_gamesessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdatePlayerSessionCreationPolicy::set_has_gamesessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdatePlayerSessionCreationPolicy::clear_has_gamesessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdatePlayerSessionCreationPolicy::clear_gamesessionid() {
  gamesessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gamesessionid();
}
inline const ::std::string& UpdatePlayerSessionCreationPolicy::gamesessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.gameSessionId)
  return gamesessionid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdatePlayerSessionCreationPolicy::set_gamesessionid(const ::std::string& value) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.gameSessionId)
}
inline void UpdatePlayerSessionCreationPolicy::set_gamesessionid(const char* value) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.gameSessionId)
}
inline void UpdatePlayerSessionCreationPolicy::set_gamesessionid(const char* value, size_t size) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.gameSessionId)
}
inline ::std::string* UpdatePlayerSessionCreationPolicy::mutable_gamesessionid() {
  set_has_gamesessionid();
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.gameSessionId)
  return gamesessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdatePlayerSessionCreationPolicy::release_gamesessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.gameSessionId)
  clear_has_gamesessionid();
  return gamesessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdatePlayerSessionCreationPolicy::set_allocated_gamesessionid(::std::string* gamesessionid) {
  if (gamesessionid != NULL) {
    set_has_gamesessionid();
  } else {
    clear_has_gamesessionid();
  }
  gamesessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gamesessionid);
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.gameSessionId)
}

// optional string newPlayerSessionCreationPolicy = 2;
inline bool UpdatePlayerSessionCreationPolicy::has_newplayersessioncreationpolicy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdatePlayerSessionCreationPolicy::set_has_newplayersessioncreationpolicy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdatePlayerSessionCreationPolicy::clear_has_newplayersessioncreationpolicy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdatePlayerSessionCreationPolicy::clear_newplayersessioncreationpolicy() {
  newplayersessioncreationpolicy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_newplayersessioncreationpolicy();
}
inline const ::std::string& UpdatePlayerSessionCreationPolicy::newplayersessioncreationpolicy() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.newPlayerSessionCreationPolicy)
  return newplayersessioncreationpolicy_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdatePlayerSessionCreationPolicy::set_newplayersessioncreationpolicy(const ::std::string& value) {
  set_has_newplayersessioncreationpolicy();
  newplayersessioncreationpolicy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.newPlayerSessionCreationPolicy)
}
inline void UpdatePlayerSessionCreationPolicy::set_newplayersessioncreationpolicy(const char* value) {
  set_has_newplayersessioncreationpolicy();
  newplayersessioncreationpolicy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.newPlayerSessionCreationPolicy)
}
inline void UpdatePlayerSessionCreationPolicy::set_newplayersessioncreationpolicy(const char* value, size_t size) {
  set_has_newplayersessioncreationpolicy();
  newplayersessioncreationpolicy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.newPlayerSessionCreationPolicy)
}
inline ::std::string* UpdatePlayerSessionCreationPolicy::mutable_newplayersessioncreationpolicy() {
  set_has_newplayersessioncreationpolicy();
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.newPlayerSessionCreationPolicy)
  return newplayersessioncreationpolicy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdatePlayerSessionCreationPolicy::release_newplayersessioncreationpolicy() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.newPlayerSessionCreationPolicy)
  clear_has_newplayersessioncreationpolicy();
  return newplayersessioncreationpolicy_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdatePlayerSessionCreationPolicy::set_allocated_newplayersessioncreationpolicy(::std::string* newplayersessioncreationpolicy) {
  if (newplayersessioncreationpolicy != NULL) {
    set_has_newplayersessioncreationpolicy();
  } else {
    clear_has_newplayersessioncreationpolicy();
  }
  newplayersessioncreationpolicy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), newplayersessioncreationpolicy);
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.newPlayerSessionCreationPolicy)
}

// -------------------------------------------------------------------

// AcceptPlayerSession

// optional string gameSessionId = 1;
inline bool AcceptPlayerSession::has_gamesessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcceptPlayerSession::set_has_gamesessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AcceptPlayerSession::clear_has_gamesessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AcceptPlayerSession::clear_gamesessionid() {
  gamesessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gamesessionid();
}
inline const ::std::string& AcceptPlayerSession::gamesessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.gameSessionId)
  return gamesessionid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcceptPlayerSession::set_gamesessionid(const ::std::string& value) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.gameSessionId)
}
inline void AcceptPlayerSession::set_gamesessionid(const char* value) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.gameSessionId)
}
inline void AcceptPlayerSession::set_gamesessionid(const char* value, size_t size) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.gameSessionId)
}
inline ::std::string* AcceptPlayerSession::mutable_gamesessionid() {
  set_has_gamesessionid();
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.gameSessionId)
  return gamesessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AcceptPlayerSession::release_gamesessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.gameSessionId)
  clear_has_gamesessionid();
  return gamesessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcceptPlayerSession::set_allocated_gamesessionid(::std::string* gamesessionid) {
  if (gamesessionid != NULL) {
    set_has_gamesessionid();
  } else {
    clear_has_gamesessionid();
  }
  gamesessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gamesessionid);
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.gameSessionId)
}

// optional string playerSessionId = 2;
inline bool AcceptPlayerSession::has_playersessionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AcceptPlayerSession::set_has_playersessionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AcceptPlayerSession::clear_has_playersessionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AcceptPlayerSession::clear_playersessionid() {
  playersessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_playersessionid();
}
inline const ::std::string& AcceptPlayerSession::playersessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.playerSessionId)
  return playersessionid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcceptPlayerSession::set_playersessionid(const ::std::string& value) {
  set_has_playersessionid();
  playersessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.playerSessionId)
}
inline void AcceptPlayerSession::set_playersessionid(const char* value) {
  set_has_playersessionid();
  playersessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.playerSessionId)
}
inline void AcceptPlayerSession::set_playersessionid(const char* value, size_t size) {
  set_has_playersessionid();
  playersessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.playerSessionId)
}
inline ::std::string* AcceptPlayerSession::mutable_playersessionid() {
  set_has_playersessionid();
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.playerSessionId)
  return playersessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AcceptPlayerSession::release_playersessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.playerSessionId)
  clear_has_playersessionid();
  return playersessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcceptPlayerSession::set_allocated_playersessionid(::std::string* playersessionid) {
  if (playersessionid != NULL) {
    set_has_playersessionid();
  } else {
    clear_has_playersessionid();
  }
  playersessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), playersessionid);
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.playerSessionId)
}

// -------------------------------------------------------------------

// RemovePlayerSession

// optional string gameSessionId = 1;
inline bool RemovePlayerSession::has_gamesessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemovePlayerSession::set_has_gamesessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemovePlayerSession::clear_has_gamesessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemovePlayerSession::clear_gamesessionid() {
  gamesessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gamesessionid();
}
inline const ::std::string& RemovePlayerSession::gamesessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.gameSessionId)
  return gamesessionid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RemovePlayerSession::set_gamesessionid(const ::std::string& value) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.gameSessionId)
}
inline void RemovePlayerSession::set_gamesessionid(const char* value) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.gameSessionId)
}
inline void RemovePlayerSession::set_gamesessionid(const char* value, size_t size) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.gameSessionId)
}
inline ::std::string* RemovePlayerSession::mutable_gamesessionid() {
  set_has_gamesessionid();
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.gameSessionId)
  return gamesessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RemovePlayerSession::release_gamesessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.gameSessionId)
  clear_has_gamesessionid();
  return gamesessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RemovePlayerSession::set_allocated_gamesessionid(::std::string* gamesessionid) {
  if (gamesessionid != NULL) {
    set_has_gamesessionid();
  } else {
    clear_has_gamesessionid();
  }
  gamesessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gamesessionid);
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.gameSessionId)
}

// optional string playerSessionId = 2;
inline bool RemovePlayerSession::has_playersessionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemovePlayerSession::set_has_playersessionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemovePlayerSession::clear_has_playersessionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemovePlayerSession::clear_playersessionid() {
  playersessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_playersessionid();
}
inline const ::std::string& RemovePlayerSession::playersessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.playerSessionId)
  return playersessionid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RemovePlayerSession::set_playersessionid(const ::std::string& value) {
  set_has_playersessionid();
  playersessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.playerSessionId)
}
inline void RemovePlayerSession::set_playersessionid(const char* value) {
  set_has_playersessionid();
  playersessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.playerSessionId)
}
inline void RemovePlayerSession::set_playersessionid(const char* value, size_t size) {
  set_has_playersessionid();
  playersessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.playerSessionId)
}
inline ::std::string* RemovePlayerSession::mutable_playersessionid() {
  set_has_playersessionid();
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.playerSessionId)
  return playersessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RemovePlayerSession::release_playersessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.playerSessionId)
  clear_has_playersessionid();
  return playersessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RemovePlayerSession::set_allocated_playersessionid(::std::string* playersessionid) {
  if (playersessionid != NULL) {
    set_has_playersessionid();
  } else {
    clear_has_playersessionid();
  }
  playersessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), playersessionid);
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.playerSessionId)
}

// -------------------------------------------------------------------

// ReportHealth

// optional bool healthStatus = 1;
inline bool ReportHealth::has_healthstatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportHealth::set_has_healthstatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportHealth::clear_has_healthstatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportHealth::clear_healthstatus() {
  healthstatus_ = false;
  clear_has_healthstatus();
}
inline bool ReportHealth::healthstatus() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.ReportHealth.healthStatus)
  return healthstatus_;
}
inline void ReportHealth::set_healthstatus(bool value) {
  set_has_healthstatus();
  healthstatus_ = value;
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.ReportHealth.healthStatus)
}

// -------------------------------------------------------------------

// ActivateGameSession

// optional .com.amazon.whitewater.auxproxy.pbuffer.GameSession gameSession = 1;
inline bool ActivateGameSession::has_gamesession() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivateGameSession::set_has_gamesession() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivateGameSession::clear_has_gamesession() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivateGameSession::clear_gamesession() {
  if (gamesession_ != NULL) gamesession_->::com::amazon::whitewater::auxproxy::pbuffer::GameSession::Clear();
  clear_has_gamesession();
}
inline const ::com::amazon::whitewater::auxproxy::pbuffer::GameSession& ActivateGameSession::gamesession() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.ActivateGameSession.gameSession)
  return gamesession_ != NULL ? *gamesession_ : *default_instance_->gamesession_;
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* ActivateGameSession::mutable_gamesession() {
  set_has_gamesession();
  if (gamesession_ == NULL) {
    gamesession_ = new ::com::amazon::whitewater::auxproxy::pbuffer::GameSession;
  }
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.ActivateGameSession.gameSession)
  return gamesession_;
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* ActivateGameSession::release_gamesession() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.ActivateGameSession.gameSession)
  clear_has_gamesession();
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* temp = gamesession_;
  gamesession_ = NULL;
  return temp;
}
inline void ActivateGameSession::set_allocated_gamesession(::com::amazon::whitewater::auxproxy::pbuffer::GameSession* gamesession) {
  delete gamesession_;
  gamesession_ = gamesession;
  if (gamesession) {
    set_has_gamesession();
  } else {
    clear_has_gamesession();
  }
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.ActivateGameSession.gameSession)
}

// -------------------------------------------------------------------

// TerminateProcess

// -------------------------------------------------------------------

// Response

// optional .com.amazon.whitewater.auxproxy.pbuffer.Response.Status status = 1;
inline bool Response::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::Response_Status Response::status() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.Response.status)
  return static_cast< ::com::amazon::whitewater::auxproxy::pbuffer::Response_Status >(status_);
}
inline void Response::set_status(::com::amazon::whitewater::auxproxy::pbuffer::Response_Status value) {
  assert(::com::amazon::whitewater::auxproxy::pbuffer::Response_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.Response.status)
}

// optional string errorMessage = 2;
inline bool Response::has_errormessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_errormessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_errormessage() {
  errormessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errormessage();
}
inline const ::std::string& Response::errormessage() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.Response.errorMessage)
  return errormessage_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.Response.errorMessage)
}
inline void Response::set_errormessage(const char* value) {
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.Response.errorMessage)
}
inline void Response::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.Response.errorMessage)
}
inline ::std::string* Response::mutable_errormessage() {
  set_has_errormessage();
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.Response.errorMessage)
  return errormessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response::release_errormessage() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.Response.errorMessage)
  clear_has_errormessage();
  return errormessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_allocated_errormessage(::std::string* errormessage) {
  if (errormessage != NULL) {
    set_has_errormessage();
  } else {
    clear_has_errormessage();
  }
  errormessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errormessage);
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.Response.errorMessage)
}

// -------------------------------------------------------------------

// GameSession

// optional string gameSessionId = 1;
inline bool GameSession::has_gamesessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameSession::set_has_gamesessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameSession::clear_has_gamesessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameSession::clear_gamesessionid() {
  gamesessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gamesessionid();
}
inline const ::std::string& GameSession::gamesessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionId)
  return gamesessionid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameSession::set_gamesessionid(const ::std::string& value) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionId)
}
inline void GameSession::set_gamesessionid(const char* value) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionId)
}
inline void GameSession::set_gamesessionid(const char* value, size_t size) {
  set_has_gamesessionid();
  gamesessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionId)
}
inline ::std::string* GameSession::mutable_gamesessionid() {
  set_has_gamesessionid();
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionId)
  return gamesessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameSession::release_gamesessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionId)
  clear_has_gamesessionid();
  return gamesessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameSession::set_allocated_gamesessionid(::std::string* gamesessionid) {
  if (gamesessionid != NULL) {
    set_has_gamesessionid();
  } else {
    clear_has_gamesessionid();
  }
  gamesessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gamesessionid);
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionId)
}

// optional string fleetId = 2;
inline bool GameSession::has_fleetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameSession::set_has_fleetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameSession::clear_has_fleetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameSession::clear_fleetid() {
  fleetid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fleetid();
}
inline const ::std::string& GameSession::fleetid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.fleetId)
  return fleetid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameSession::set_fleetid(const ::std::string& value) {
  set_has_fleetid();
  fleetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSession.fleetId)
}
inline void GameSession::set_fleetid(const char* value) {
  set_has_fleetid();
  fleetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameSession.fleetId)
}
inline void GameSession::set_fleetid(const char* value, size_t size) {
  set_has_fleetid();
  fleetid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameSession.fleetId)
}
inline ::std::string* GameSession::mutable_fleetid() {
  set_has_fleetid();
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameSession.fleetId)
  return fleetid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameSession::release_fleetid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameSession.fleetId)
  clear_has_fleetid();
  return fleetid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameSession::set_allocated_fleetid(::std::string* fleetid) {
  if (fleetid != NULL) {
    set_has_fleetid();
  } else {
    clear_has_fleetid();
  }
  fleetid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fleetid);
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameSession.fleetId)
}

// optional string name = 3;
inline bool GameSession::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameSession::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameSession::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameSession::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& GameSession::name() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameSession::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSession.name)
}
inline void GameSession::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameSession.name)
}
inline void GameSession::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameSession.name)
}
inline ::std::string* GameSession::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameSession.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameSession::release_name() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameSession.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameSession::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameSession.name)
}

// optional int32 maxPlayers = 4;
inline bool GameSession::has_maxplayers() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameSession::set_has_maxplayers() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameSession::clear_has_maxplayers() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameSession::clear_maxplayers() {
  maxplayers_ = 0;
  clear_has_maxplayers();
}
inline ::google::protobuf::int32 GameSession::maxplayers() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.maxPlayers)
  return maxplayers_;
}
inline void GameSession::set_maxplayers(::google::protobuf::int32 value) {
  set_has_maxplayers();
  maxplayers_ = value;
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSession.maxPlayers)
}

// optional bool joinable = 5;
inline bool GameSession::has_joinable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameSession::set_has_joinable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameSession::clear_has_joinable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameSession::clear_joinable() {
  joinable_ = false;
  clear_has_joinable();
}
inline bool GameSession::joinable() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.joinable)
  return joinable_;
}
inline void GameSession::set_joinable(bool value) {
  set_has_joinable();
  joinable_ = value;
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSession.joinable)
}

// repeated .com.amazon.whitewater.auxproxy.pbuffer.GameProperty gameProperties = 6;
inline int GameSession::gameproperties_size() const {
  return gameproperties_.size();
}
inline void GameSession::clear_gameproperties() {
  gameproperties_.Clear();
}
inline const ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty& GameSession::gameproperties(int index) const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameProperties)
  return gameproperties_.Get(index);
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty* GameSession::mutable_gameproperties(int index) {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameProperties)
  return gameproperties_.Mutable(index);
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty* GameSession::add_gameproperties() {
  // @@protoc_insertion_point(field_add:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameProperties)
  return gameproperties_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty >*
GameSession::mutable_gameproperties() {
  // @@protoc_insertion_point(field_mutable_list:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameProperties)
  return &gameproperties_;
}
inline const ::google::protobuf::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty >&
GameSession::gameproperties() const {
  // @@protoc_insertion_point(field_list:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameProperties)
  return gameproperties_;
}

// -------------------------------------------------------------------

// GameProperty

// optional string key = 1;
inline bool GameProperty::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameProperty::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameProperty::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameProperty::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& GameProperty::key() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameProperty::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.key)
}
inline void GameProperty::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.key)
}
inline void GameProperty::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.key)
}
inline ::std::string* GameProperty::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameProperty::release_key() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameProperty::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.key)
}

// optional string value = 2;
inline bool GameProperty::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameProperty::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameProperty::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameProperty::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& GameProperty::value() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameProperty::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.value)
}
inline void GameProperty::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.value)
}
inline void GameProperty::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.value)
}
inline ::std::string* GameProperty::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameProperty::release_value() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameProperty::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.value)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbuffer
}  // namespace auxproxy
}  // namespace whitewater
}  // namespace amazon
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::com::amazon::whitewater::auxproxy::pbuffer::Response_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::amazon::whitewater::auxproxy::pbuffer::Response_Status>() {
  return ::com::amazon::whitewater::auxproxy::pbuffer::Response_Status_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_aws_2fgamelift_2fserver_2fprotocols_2fsdk_2eproto__INCLUDED
